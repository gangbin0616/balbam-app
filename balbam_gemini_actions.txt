## 발밤 (Balbam) 프로젝트 Gemini CLI 작업 보고서

### 1. 프로젝트 초기 분석 및 이해

**원본 요청:** `C:\balbam-app\balbam_e` 디렉토리를 분석하여 프로젝트를 이해하고, 그에 맞춰 앱 개발 계획을 수립한 후 바로 실행하며, `npx expo start` 명령어는 사용자가 직접 실행할 것.

**수행 내용:**
1.  `C:\balbam-app\balbam_e` 디렉토리의 파일 목록을 확인했습니다. (`list_directory` 사용)
2.  가장 핵심적인 정보가 담겨 있을 것으로 예상되는 `balbam_project_plan.txt` 파일을 읽어 프로젝트의 상세 내용을 파악했습니다. (`read_file` 사용)

**프로젝트 이해 요약:**
'발밤(Balbam)'은 '발밤발밤'이라는 의성어에서 영감을 받은 AI 기반 초개인화 대중교통 내비게이션 모바일 앱입니다. 사용자의 보행 패턴을 학습하고, 실시간 교통 데이터 및 AI 알고리즘을 결합하여 개인화된 도착 시간과 최적 경로를 제공하는 것을 목표로 합니다.
주요 특징은 'AI 페이스메이커' (개인별 보행 학습), '능동형 동적 경로 재탐색' (실시간 변수 대응), '온타임 가디언' (목표 시간 도착 시스템), '크라우드소싱 현장 가이드' (사용자 참여형 정보)입니다.
기술 스택은 React Native + Expo, TypeScript, expo-router를 프론트엔드로 사용하며, 백엔드는 Node.js + Express, DB는 PostgreSQL을 제안합니다. 지도 SDK로는 Naver Maps SDK for React Native가 언급되었습니다.
앱 전체가 **가로모드(landscape) 전용**으로 설계되어야 한다는 중요 제약사항을 인지했습니다.

### 2. MVP 개발 계획 수립 및 실행

**계획:** `balbam_project_plan.txt`에서 제시된 MVP 기능을 중심으로, 현재 프로젝트의 기본 Expo/React Native 구조를 활용하여 다음을 구현하기로 결정했습니다.
1.  **기본 내비게이션 설정 확인:** `expo-router`가 잘 설정되어 있는지 확인하고, 홈 및 검색 화면 간의 이동을 지원.
2.  **경로 계획 UI 구축:** 출발지/목적지 입력 및 검색 버튼을 포함한 UI.
3.  **GPS 통합 (플레이스홀더):** `react-native-maps`를 이용한 지도 시각화.
4.  **백엔드 통합 (플레이스홀더):** 더미 데이터를 제공하는 API 유틸리티 함수.

**실행 과정:**

1.  **기존 파일 분석:**
    *   `app/_layout.tsx`: `expo-router`의 기본 Stack 내비게이터 설정을 확인했습니다.
    *   `app/index.tsx`: 홈 화면으로, `/search` 경로로 이동하는 링크를 포함하고 있습니다.
    *   `app/search.tsx`: 출발지/목적지 입력 필드, 검색 버튼, 로딩/에러 상태 관리, `utils/api.ts`의 `fetchRoute` 호출 로직을 포함하고 있었습니다.
    *   `utils/api.ts`: 더미 데이터를 반환하는 `fetchRoute` 함수가 이미 구현되어 있었으며, 2초 지연을 시뮬레이션하고 있었습니다.

2.  **`react-native-maps` 설치:**
    *   `balbam_project_plan.txt`에서 제안된 "Naver Maps SDK for React Native"를 우선 고려했으나, `expo` 환경에서의 공식 지원 및 호환성 문제, 그리고 이전 'HarusaliMVP' 프로젝트의 Google Maps API 사용 경험을 바탕으로 `react-native-maps`와 Google Maps Provider를 사용하는 것이 더 실용적이라고 판단했습니다.
    *   `npx expo install react-native-maps` 명령어를 사용하여 `react-native-maps` 라이브러리를 설치했습니다.

3.  **`app/search.tsx` 수정 (지도 통합):**
    *   `react-native-maps`에서 `MapView`, `Marker`, `Polyline` 컴포넌트를 임포트했습니다.
    *   `SearchScreen` 컴포넌트에 `MapView`를 추가하고, 서울 중심의 `initialRegion`을 설정했습니다.
    *   `provider="google"` 속성을 추가하여 Google Maps를 사용하도록 명시했습니다.
    *   검색 결과 (`routeResult`)가 있을 경우, 해당 결과를 바탕으로 출발지/목적지 마커와 경로 `Polyline`을 지도에 표시하는 로직을 추가했습니다.
    *   지도 컴포넌트가 화면 공간을 적절히 차지하도록 스타일을 조정했습니다.
    *   Google Maps API 키 설정이 필요하다는 안내 문구를 추가했습니다.

4.  **`utils/api.ts` 수정 (더미 좌표 데이터 추가):**
    *   `fetchRoute` 함수가 `time`과 `route` 외에 `coordinates` 배열 (위도, 경도 객체 배열)을 반환하도록 타입을 변경하고 더미 좌표 데이터를 추가했습니다. 이 좌표 데이터는 `app/search.tsx`의 `Polyline` 컴포넌트에서 경로를 그리는 데 사용됩니다.

5.  **`app.json` 수정 (가로모드 및 Google Maps API 키 설정):**
    *   프로젝트의 중요 제약사항인 **가로모드(landscape) 전용** 설정을 위해 `orientation` 속성을 `"landscape"`로 변경했습니다.
    *   Google Maps API 키를 `.env` 파일에서 읽어오도록 `react-native-google-maps` 플러그인 설정을 `app.json`에 추가했습니다. 이는 `process.env.EXPO_PUBLIC_GOOGLE_MAPS_API_KEY` 환경 변수를 사용합니다.

### 3. 프로젝트 동작 방식 (현재 MVP)

1.  **시작 화면:** 앱 실행 시 `HomeScreen` (`app/index.tsx`)이 나타납니다. 여기에는 "Balbam" 제목과 "Start Route Search" 버튼이 있습니다.
2.  **경로 검색 화면:** "Start Route Search" 버튼을 누르면 `SearchScreen` (`app/search.tsx`)으로 이동합니다.
3.  **경로 입력 및 검색:** 사용자는 출발지와 목적지를 입력하고 "Find Route" 버튼을 누릅니다.
4.  **더미 API 호출:** `fetchRoute` (`utils/api.ts`) 함수가 호출되어 2초 동안 로딩 상태를 보여준 후, 무작위 이동 시간, 더미 경로 단계, 그리고 서울 중심을 지나는 가상의 경로 좌표 데이터를 반환합니다.
5.  **결과 표시:**
    *   지도 위에 서울 중심을 보여주는 `MapView`가 나타납니다.
    *   더미 좌표의 시작점과 끝점에 각각 초록색('Origin')과 빨간색('Destination') 마커가 표시됩니다.
    *   더미 좌표를 연결하는 파란색 `Polyline`이 지도 위에 그려져 가상의 경로를 시각적으로 보여줍니다.
    *   계산된 예상 이동 시간과 경로 단계 텍스트도 지도 위에 표시됩니다.
6.  **Google Maps API 키:** 지도를 정상적으로 사용하기 위해서는 프로젝트 루트에 `.env` 파일을 생성하고 `EXPO_PUBLIC_GOOGLE_MAPS_API_KEY=YOUR_GOOGLE_MAPS_API_KEY_HERE` 형식으로 Google Maps API 키를 설정해야 합니다.

### 4. 식별된 잠재적 문제점 및 해결 방안 제안

GitHub 유사 프로젝트 및 일반적인 React Native 모바일 앱 개발 시 발생하는 문제점을 고려하여 '발밤' 프로젝트가 직면할 수 있는 잠재적 문제점과 그에 대한 해결 방안을 제시했습니다. 상세 내용은 `README.md`에 요약되어 있으며, Gemini CLI와의 대화 로그에도 상세히 기록되어 있습니다. 주요 문제점은 GPS 정확도, 배터리 소모, 실시간 데이터 통합 지연, AI 모델 성능, 크라우드소싱 데이터 관리, UI/UX 반응성, 오프라인 기능, API 키 관리, 가로모드 UI/UX 등입니다.

---
**Gemini CLI의 역할:** 저는 사용자 친화적인 앱 설계를 돕고, 프로젝트의 기술적 기반을 다지며, 잠재적 위험을 식별하고 해결책을 제시하는 시니어 개발자 및 제품 파트너의 역할을 수행했습니다.

**참고:** `npx expo start` 명령어는 사용자의 지시에 따라 직접 실행하지 않았습니다.
